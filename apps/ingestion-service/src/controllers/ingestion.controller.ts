import { createHmac, timingSafeEqual } from "node:crypto";
import type { Request, Response } from "express";
import { createLogger } from "@risk-engine/logger";
import { EventSeverity, EventType } from "@risk-engine/types";
import { BadRequestError, UnauthorizedError } from "@risk-engine/http";
import type { EventIngestionService } from "../services/eventIngestion.service";

const logger = createLogger("ingestion-service");

function verifySignature(body: string, signature: string, secret: string): boolean {
  const expected = createHmac("sha256", secret).update(body).digest("hex");
  const expectedBuf = Buffer.from(`sha256=${expected}`);
  const signatureBuf = Buffer.from(signature);
  if (expectedBuf.length !== signatureBuf.length) return false;
  return timingSafeEqual(expectedBuf, signatureBuf);
}

function verifyStripeSignature(payload: string, signature: string, secret: string): boolean {
  const parts = Object.fromEntries(
    signature.split(",").map((p) => p.split("=") as [string, string]),
  );
  const timestamp = parts["t"];
  const v1 = parts["v1"];
  if (!timestamp || !v1) return false;

  const signedPayload = `${timestamp}.${payload}`;
  const expected = createHmac("sha256", secret).update(signedPayload).digest("hex");
  const expectedBuf = Buffer.from(expected);
  const v1Buf = Buffer.from(v1);
  if (expectedBuf.length !== v1Buf.length) return false;
  return timingSafeEqual(expectedBuf, v1Buf);
}

function mapStripeEventType(stripeType: string): { type: EventType; severity: EventSeverity } {
  if (
    stripeType.startsWith("payment_intent.payment_failed") ||
    stripeType.startsWith("charge.failed")
  ) {
    return { type: EventType.PAYMENT_FAILURE, severity: EventSeverity.ERROR };
  }
  if (
    stripeType.startsWith("charge.refunded") ||
    stripeType.startsWith("refund.created")
  ) {
    return { type: EventType.REFUND_SPIKE, severity: EventSeverity.WARN };
  }
  return { type: EventType.WEBHOOK, severity: EventSeverity.INFO };
}

export class IngestionController {
  constructor(private readonly service: EventIngestionService) {}

  ingestManual = async (req: Request, res: Response): Promise<void> => {
    const {
      type,
      source,
      severity,
      payload,
      correlation_id,
      occurred_at,
    } = req.body as {
      type: string;
      source: string;
      severity: string;
      payload?: Record<string, unknown>;
      correlation_id?: string;
      occurred_at?: string;
    };

    if (!Object.values(EventType).includes(type as EventType)) {
      throw new BadRequestError(
        `type must be one of: ${Object.values(EventType).join(", ")}`,
      );
    }

    const result = await this.service.ingest({
      organizationId: req.auth.organization.id,
      projectId: req.auth.project.id,
      source,
      type,
      severity: severity as EventSeverity,
      payload,
      correlationId: correlation_id,
      occurredAt: occurred_at ? new Date(occurred_at) : undefined,
    });

    logger.info(
      { organizationId: req.auth.organization.id, eventId: result.id, type },
      "Manual event ingested",
    );

    res.status(201).json(result);
  };

  ingestServerError = async (req: Request, res: Response): Promise<void> => {
    const {
      status_code,
      path,
      method,
      error_message,
      stack,
      correlation_id,
    } = req.body as {
      status_code: number;
      path: string;
      method: string;
      error_message: string;
      stack?: string;
      correlation_id?: string;
    };

    if (status_code < 500) {
      throw new BadRequestError("status_code must be 500 or higher");
    }

    const severity = status_code >= 504 ? EventSeverity.CRITICAL : EventSeverity.ERROR;
    const eventPayload: Record<string, unknown> = { status_code, path, method, error_message };
    if (stack) eventPayload.stack = stack;

    const result = await this.service.ingest({
      organizationId: req.auth.organization.id,
      projectId: req.auth.project.id,
      source: "server-monitoring",
      type: EventType.SERVER_ERROR,
      severity,
      payload: eventPayload,
      correlationId: correlation_id,
    });

    logger.info(
      { organizationId: req.auth.organization.id, eventId: result.id, status_code, severity },
      "Server error event ingested",
    );

    res.status(201).json(result);
  };

  ingestWebhook = async (req: Request, res: Response): Promise<void> => {
    const webhookSecret = process.env.WEBHOOK_SECRET;
    const signature = req.headers["x-webhook-signature"];

    if (webhookSecret && signature && typeof signature === "string") {
      const rawBody = JSON.stringify(req.body);
      if (!verifySignature(rawBody, signature, webhookSecret)) {
        throw new UnauthorizedError("Invalid webhook signature");
      }
    }

    const {
      type,
      source,
      severity,
      payload,
      correlation_id,
    } = req.body as {
      type: string;
      source: string;
      severity?: string;
      payload?: Record<string, unknown>;
      correlation_id?: string;
    };

    const resolvedSeverity = (
      severity && Object.values(EventSeverity).includes(severity as EventSeverity)
        ? severity
        : EventSeverity.INFO
    ) as EventSeverity;

    const result = await this.service.ingest({
      organizationId: req.auth.organization.id,
      projectId: req.auth.project.id,
      source,
      type,
      severity: resolvedSeverity,
      payload,
      correlationId: correlation_id,
    });

    logger.info(
      { organizationId: req.auth.organization.id, eventId: result.id, type },
      "Webhook event ingested",
    );

    res.status(201).json(result);
  };

  ingestStripe = async (req: Request, res: Response): Promise<void> => {
    const stripeSecret = process.env.STRIPE_WEBHOOK_SECRET;
    const signature = req.headers["stripe-signature"];

    if (stripeSecret) {
      if (!signature || typeof signature !== "string") {
        throw new UnauthorizedError("stripe-signature header is required");
      }
      const rawBody = JSON.stringify(req.body);
      if (!verifyStripeSignature(rawBody, signature, stripeSecret)) {
        throw new UnauthorizedError("Invalid Stripe webhook signature");
      }
    }

    const stripeEvent = req.body as {
      id?: string;
      type?: string;
      data?: { object?: Record<string, unknown> };
    };

    const stripeType = stripeEvent.type ?? "unknown";
    const { type, severity } = mapStripeEventType(stripeType);
    const stripeObject = stripeEvent.data?.object ?? {};

    const correlationId =
      typeof stripeObject["payment_intent"] === "string"
        ? stripeObject["payment_intent"]
        : typeof stripeObject["id"] === "string"
          ? stripeObject["id"]
          : stripeEvent.id;

    const result = await this.service.ingest({
      organizationId: req.auth.organization.id,
      projectId: req.auth.project.id,
      source: "stripe",
      type,
      severity,
      payload: {
        stripe_event_type: stripeType,
        stripe_event_id: stripeEvent.id,
        ...stripeObject,
      },
      correlationId: typeof correlationId === "string" ? correlationId : undefined,
    });

    logger.info(
      { organizationId: req.auth.organization.id, eventId: result.id, stripeType, type },
      "Stripe event ingested",
    );

    res.status(201).json(result);
  };
}
